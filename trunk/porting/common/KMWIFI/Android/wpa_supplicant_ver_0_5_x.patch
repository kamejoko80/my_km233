diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/Android.mk /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/Android.mk
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/Android.mk	2012-11-19 12:58:30.781108201 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/Android.mk	2012-11-21 23:18:27.000000000 +0700
@@ -21,12 +21,17 @@ ifeq ($(WPA_SUPPLICANT_VERSION),VER_0_5_
 
 LOCAL_PATH := $(call my-dir)
 
-WPA_BUILD_SUPPLICANT := false
+BOARD_WPA_SUPPLICANT_DRIVER := AWEXT
+WPA_BUILD_SUPPLICANT := true
 ifneq ($(TARGET_SIMULATOR),true)
   ifneq ($(BOARD_WPA_SUPPLICANT_DRIVER),)
     WPA_BUILD_SUPPLICANT := true
     CONFIG_DRIVER_$(BOARD_WPA_SUPPLICANT_DRIVER) = y
   endif
+  ifeq ($(BOARD_HAVE_WIFI),true)
+    WPA_BUILD_SUPPLICANT := true
+    CONFIG_DRIVER_WEXT = y
+  endif
 endif
 
 include $(LOCAL_PATH)/.config
@@ -46,7 +51,7 @@ L_CFLAGS += -DWPA_UNICODE_SSID
 L_CFLAGS += -DOPENSSL_NO_ENGINE
 
 INCLUDES = external/openssl/include frameworks/base/cmds/keystore
-  
+
 OBJS = config.c common.c md5.c md4.c rc4.c sha1.c des.c
 OBJS_p = wpa_passphrase.c sha1.c md5.c md4.c common.c des.c
 OBJS_c = wpa_cli.c wpa_ctrl.c
@@ -96,6 +101,12 @@ OBJS_d += driver_hostap.c
 CONFIG_WIRELESS_EXTENSION=y
 endif
 
+ifdef CONFIG_DRIVER_AWEXT
+L_CFLAGS += -DCONFIG_DRIVER_AWEXT
+OBJS_d += driver_awext.c
+CONFIG_WIRELESS_EXTENSION=y
+endif
+
 ifdef CONFIG_DRIVER_WEXT
 L_CFLAGS += -DCONFIG_DRIVER_WEXT
 CONFIG_WIRELESS_EXTENSION=y
@@ -698,17 +709,17 @@ include $(BUILD_EXECUTABLE)
 #include $(BUILD_EXECUTABLE)
 #
 ########################
-#
-#local_target_dir := $(TARGET_OUT)/etc/wifi
-#
-#include $(CLEAR_VARS)
-#LOCAL_MODULE := wpa_supplicant.conf
-#LOCAL_MODULE_TAGS := user
-#LOCAL_MODULE_CLASS := ETC
-#LOCAL_MODULE_PATH := $(local_target_dir)
-#LOCAL_SRC_FILES := $(LOCAL_MODULE)
-#include $(BUILD_PREBUILT)
-#
+
+local_target_dir := $(TARGET_OUT)/etc/wifi
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := wpa_supplicant.conf
+LOCAL_MODULE_TAGS := user
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(local_target_dir)
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+include $(BUILD_PREBUILT)
+
 ########################
 
 endif # ifeq ($(WPA_BUILD_SUPPLICANT),true)
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/common.c /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/common.c
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/common.c	2012-11-19 12:58:30.547108209 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/common.c	2012-11-22 00:01:06.000000000 +0700
@@ -20,7 +20,8 @@
 #ifdef CONFIG_DEBUG_FILE
 static FILE *out_file = NULL;
 #endif /* CONFIG_DEBUG_FILE */
-int wpa_debug_level = MSG_INFO;
+//int wpa_debug_level = MSG_INFO;
+int wpa_debug_level = MSG_DEBUG;
 int wpa_debug_show_keys = 0;
 int wpa_debug_timestamp = 0;
 
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/common.h /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/common.h
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/common.h	2012-11-19 12:58:30.793108200 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/common.h	2012-11-22 00:02:15.000000000 +0700
@@ -270,7 +270,7 @@ void android_printf(int level, char *for
 
 #define wpa_printf(level, ...) \
         do {                                            \
-            if ((level) >= MSG_INFO) {                  \
+            if ((level) >= MSG_DEBUG) {                  \
                 android_printf((level), __VA_ARGS__);   \
             }                                           \
         } while (0)
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/driver_awext.c /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/driver_awext.c
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/driver_awext.c	1970-01-01 07:00:00.000000000 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/driver_awext.c	2012-11-21 23:35:54.000000000 +0700
@@ -0,0 +1,919 @@
+/*
+ * WEXT Emulation for Android SIOCSIWPRIV ioctl with generic Linux Wireless Extensions
+ * Copyright (c) 2010, Nicu Pavel <npavel@linuxconsulting.ro>
+ * Copyright (c) 2003-2007, Jouni Malinen <j@w1.fi>
+ *
+ * Code based on Jim Huang <jserv@0xlab.org> e9bd7cc3d137eb56ebd4220d4077563743ab6723
+ * patch for 0xdroid
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ *
+ */
+
+#include "includes.h"
+#include <sys/ioctl.h>
+#include <net/if_arp.h>
+#include <net/if.h>
+
+#include "wireless_copy.h"
+#include "common.h"
+#include "driver.h"
+#include "l2_packet.h"
+#include "eloop.h"
+#include "wpa_supplicant.h"
+#include "priv_netlink.h"
+#include "driver_awext.h"
+#include "wpa.h"
+#include "wpa_ctrl.h"
+#include "wpa_supplicant_i.h"
+#include "config_ssid.h"
+
+#ifdef CONFIG_CLIENT_MLME
+#include <netpacket/packet.h>
+#include <hostapd_ioctl.h>
+#include <ieee80211_common.h>
+/* from net/mac80211.h */
+enum {
+	MODE_IEEE80211A = 0 /* IEEE 802.11a */,
+	MODE_IEEE80211B = 1 /* IEEE 802.11b only */,
+	MODE_ATHEROS_TURBO = 2 /* Atheros Turbo mode (2x.11a at 5 GHz) */,
+	MODE_IEEE80211G = 3 /* IEEE 802.11g (and 802.11b compatibility) */,
+	MODE_ATHEROS_TURBOG = 4 /* Atheros Turbo mode (2x.11g at 2.4 GHz) */,
+	NUM_IEEE80211_MODES = 5
+};
+
+#include "mlme.h"
+
+#ifndef ETH_P_ALL
+#define ETH_P_ALL 0x0003
+#endif
+#endif /* CONFIG_CLIENT_MLME */
+
+struct wpa_driver_awext_data {
+	struct wpa_driver_wext_data *wext; /* structure for wext */
+	void *ctx;
+	char ifname[IFNAMSIZ + 1];
+	int ioctl_sock;
+	u8 ssid[32];
+	unsigned int ssid_len;
+};
+
+static int wpa_driver_awext_set_auth_param(struct wpa_driver_awext_data *drv,
+					  int idx, u32 value)
+{
+	struct iwreq iwr;
+	int ret = 0;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.param.flags = idx & IW_AUTH_INDEX;
+	iwr.u.param.value = value;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWAUTH, &iwr) < 0) {
+		if (errno != EOPNOTSUPP) {
+			wpa_printf(MSG_DEBUG, "WEXT: SIOCSIWAUTH(param %d "
+				   "value 0x%x) failed: %s)",
+				   idx, value, strerror(errno));
+		}
+		ret = errno == EOPNOTSUPP ? -2 : -1;
+	}
+
+	return ret;
+}
+
+static int wpa_driver_awext_set_auth_alg(void *priv, int auth_alg)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	int algs = 0, res;
+
+	if (auth_alg & AUTH_ALG_OPEN_SYSTEM)
+		algs |= IW_AUTH_ALG_OPEN_SYSTEM;
+	if (auth_alg & AUTH_ALG_SHARED_KEY)
+		algs |= IW_AUTH_ALG_SHARED_KEY;
+	if (auth_alg & AUTH_ALG_LEAP)
+		algs |= IW_AUTH_ALG_LEAP;
+	if (algs == 0) {
+		/* at least one algorithm should be set */
+		algs = IW_AUTH_ALG_OPEN_SYSTEM;
+	}
+
+	res = wpa_driver_awext_set_auth_param(drv, IW_AUTH_80211_AUTH_ALG, algs);
+	drv->wext->auth_alg_fallback = res == -2;
+	return res;
+}
+
+static int wpa_driver_awext_set_gen_ie(void *priv, const u8 *ie,
+				      size_t ie_len)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t) ie;
+	iwr.u.data.length = ie_len;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWGENIE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWGENIE]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int wpa_driver_awext_cipher2wext(int cipher)
+{
+	switch (cipher) {
+	case CIPHER_NONE:
+		return IW_AUTH_CIPHER_NONE;
+	case CIPHER_WEP40:
+		return IW_AUTH_CIPHER_WEP40;
+	case CIPHER_TKIP:
+		return IW_AUTH_CIPHER_TKIP;
+	case CIPHER_CCMP:
+		return IW_AUTH_CIPHER_CCMP;
+	case CIPHER_WEP104:
+		return IW_AUTH_CIPHER_WEP104;
+	default:
+		return 0;
+	}
+}
+
+
+static int wpa_driver_awext_keymgmt2wext(int keymgmt)
+{
+	switch (keymgmt) {
+	case KEY_MGMT_802_1X:
+	case KEY_MGMT_802_1X_NO_WPA:
+		return IW_AUTH_KEY_MGMT_802_1X;
+	case KEY_MGMT_PSK:
+		return IW_AUTH_KEY_MGMT_PSK;
+	default:
+		return 0;
+	}
+}
+
+
+static int
+wpa_driver_awext_auth_alg_fallback(struct wpa_driver_awext_data *drv,
+				  struct wpa_driver_associate_params *params)
+{
+	struct iwreq iwr;
+	int ret = 0;
+
+	wpa_printf(MSG_DEBUG, "WEXT: Driver did not support "
+		   "SIOCSIWAUTH for AUTH_ALG, trying SIOCSIWENCODE");
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	/* Just changing mode, not actual keys */
+	iwr.u.encoding.flags = 0;
+	iwr.u.encoding.pointer = (caddr_t) NULL;
+	iwr.u.encoding.length = 0;
+
+	/*
+	 * Note: IW_ENCODE_{OPEN,RESTRICTED} can be interpreted to mean two
+	 * different things. Here they are used to indicate Open System vs.
+	 * Shared Key authentication algorithm. However, some drivers may use
+	 * them to select between open/restricted WEP encrypted (open = allow
+	 * both unencrypted and encrypted frames; restricted = only allow
+	 * encrypted frames).
+	 */
+
+	if (!drv->wext->use_crypt) {
+		iwr.u.encoding.flags |= IW_ENCODE_DISABLED;
+	} else {
+		if (params->auth_alg & AUTH_ALG_OPEN_SYSTEM)
+			iwr.u.encoding.flags |= IW_ENCODE_OPEN;
+		if (params->auth_alg & AUTH_ALG_SHARED_KEY)
+			iwr.u.encoding.flags |= IW_ENCODE_RESTRICTED;
+	}
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWENCODE]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+
+
+static int
+wpa_driver_awext_associate(void *priv,
+			  struct wpa_driver_associate_params *params)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	int ret = 0;
+	int allow_unencrypted_eapol;
+	int value, flags;
+
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+
+	if (wpa_driver_awext_get_ifflags(drv, &flags) == 0) {
+		if (!(flags & IFF_UP)) {
+			wpa_driver_awext_set_ifflags(drv, flags | IFF_UP);
+		}
+	}
+
+	/*
+	 * If the driver did not support SIOCSIWAUTH, fallback to
+	 * SIOCSIWENCODE here.
+	 */
+	if (drv->wext->auth_alg_fallback &&
+	    wpa_driver_awext_auth_alg_fallback(drv, params) < 0)
+		ret = -1;
+
+	if (!params->bssid &&
+	    wpa_driver_awext_set_bssid(drv, NULL) < 0)
+		ret = -1;
+
+	if (wpa_driver_awext_set_mode(drv, params->mode) < 0)
+		ret = -1;
+	/* TODO: should consider getting wpa version and cipher/key_mgmt suites
+	 * from configuration, not from here, where only the selected suite is
+	 * available */
+	if (wpa_driver_awext_set_gen_ie(drv, params->wpa_ie, params->wpa_ie_len)
+	    < 0)
+		ret = -1;
+	if (params->wpa_ie == NULL || params->wpa_ie_len == 0)
+		value = IW_AUTH_WPA_VERSION_DISABLED;
+	else if (params->wpa_ie[0] == RSN_INFO_ELEM)
+		value = IW_AUTH_WPA_VERSION_WPA2;
+	else
+		value = IW_AUTH_WPA_VERSION_WPA;
+	if (wpa_driver_awext_set_auth_param(drv,
+					   IW_AUTH_WPA_VERSION, value) < 0)
+		ret = -1;
+	value = wpa_driver_awext_cipher2wext(params->pairwise_suite);
+	if (wpa_driver_awext_set_auth_param(drv,
+					   IW_AUTH_CIPHER_PAIRWISE, value) < 0)
+		ret = -1;
+	value = wpa_driver_awext_cipher2wext(params->group_suite);
+	if (wpa_driver_awext_set_auth_param(drv,
+					   IW_AUTH_CIPHER_GROUP, value) < 0)
+		ret = -1;
+	value = wpa_driver_awext_keymgmt2wext(params->key_mgmt_suite);
+	if (wpa_driver_awext_set_auth_param(drv,
+					   IW_AUTH_KEY_MGMT, value) < 0)
+		ret = -1;
+	value = params->key_mgmt_suite != KEY_MGMT_NONE ||
+		params->pairwise_suite != CIPHER_NONE ||
+		params->group_suite != CIPHER_NONE ||
+		params->wpa_ie_len;
+	if (wpa_driver_awext_set_auth_param(drv,
+					   IW_AUTH_PRIVACY_INVOKED, value) < 0)
+		ret = -1;
+
+	/* Allow unencrypted EAPOL messages even if pairwise keys are set when
+	 * not using WPA. IEEE 802.1X specifies that these frames are not
+	 * encrypted, but WPA encrypts them when pairwise keys are in use. */
+	if (params->key_mgmt_suite == KEY_MGMT_802_1X ||
+	    params->key_mgmt_suite == KEY_MGMT_PSK)
+		allow_unencrypted_eapol = 0;
+	else
+		allow_unencrypted_eapol = 1;
+
+	if (wpa_driver_awext_set_auth_param(drv,
+					   IW_AUTH_RX_UNENCRYPTED_EAPOL,
+					   allow_unencrypted_eapol) < 0)
+		ret = -1;
+	if (params->freq && wpa_driver_awext_set_freq(drv, params->freq) < 0)
+		ret = -1;
+	if (wpa_driver_awext_set_ssid(drv, params->ssid, params->ssid_len) < 0)
+		ret = -1;
+	if (params->bssid &&
+	    wpa_driver_awext_set_bssid(drv, params->bssid) < 0)
+		ret = -1;
+
+	return ret;
+}
+
+
+static int wpa_driver_awext_set_countermeasures(void *priv,
+					       int enabled)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	return wpa_driver_awext_set_auth_param(drv,
+					      IW_AUTH_TKIP_COUNTERMEASURES,
+					      enabled);
+}
+
+static int wpa_driver_awext_set_drop_unencrypted(void *priv,
+						int enabled)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	drv->wext->use_crypt = enabled;
+	return wpa_driver_awext_set_auth_param(drv, IW_AUTH_DROP_UNENCRYPTED,
+					      enabled);
+}
+
+static int wpa_driver_awext_mlme(struct wpa_driver_awext_data *drv,
+				const u8 *addr, int cmd, int reason_code)
+{
+	struct iwreq iwr;
+	struct iw_mlme mlme;
+	int ret = 0;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	os_memset(&mlme, 0, sizeof(mlme));
+	mlme.cmd = cmd;
+	mlme.reason_code = reason_code;
+	mlme.addr.sa_family = ARPHRD_ETHER;
+	os_memcpy(mlme.addr.sa_data, addr, ETH_ALEN);
+	iwr.u.data.pointer = (caddr_t) &mlme;
+	iwr.u.data.length = sizeof(mlme);
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWMLME, &iwr) < 0) {
+		perror("ioctl[SIOCSIWMLME]");
+		ret = -1;
+	}
+
+	return ret;
+}
+#ifdef CONFIG_CLIENT_MLME
+static int wpa_driver_awext_open_mlme(struct wpa_driver_awext_data *drv)
+{
+	int flags, ifindex, s, *i;
+	struct sockaddr_ll addr;
+	struct iwreq iwr;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	i = (int *) iwr.u.name;
+	*i++ = PRISM2_PARAM_USER_SPACE_MLME;
+	*i++ = 1;
+
+	if (ioctl(drv->ioctl_sock, PRISM2_IOCTL_PRISM2_PARAM, &iwr) < 0) {
+		wpa_printf(MSG_ERROR, "WEXT: Failed to configure driver to "
+			   "use user space MLME");
+		return -1;
+	}
+
+	ifindex = if_nametoindex(drv->wext->mlmedev);
+	if (ifindex == 0) {
+		wpa_printf(MSG_ERROR, "WEXT: mlmedev='%s' not found",
+			   drv->mlmedev);
+		return -1;
+	}
+
+	if (wpa_driver_awext_get_ifflags_ifname(drv, drv->wext->mlmedev, &flags) != 0
+	    || wpa_driver_awext_set_ifflags_ifname(drv, drv->wext->mlmedev,
+						  flags | IFF_UP) != 0) {
+		wpa_printf(MSG_ERROR, "WEXT: Could not set interface "
+			   "'%s' UP", drv->mlmedev);
+		return -1;
+	}
+
+	s = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
+	if (s < 0) {
+		perror("socket[PF_PACKET,SOCK_RAW]");
+		return -1;
+	}
+
+	os_memset(&addr, 0, sizeof(addr));
+	addr.sll_family = AF_PACKET;
+	addr.sll_ifindex = ifindex;
+
+	if (bind(s, (struct sockaddr *) &addr, sizeof(addr)) < 0) {
+		perror("bind(MLME)");
+		return -1;
+	}
+
+	if (eloop_register_read_sock(s, wpa_driver_awext_mlme_read, drv, NULL))
+	{
+		wpa_printf(MSG_ERROR, "WEXT: Could not register MLME read "
+			   "socket");
+		close(s);
+		return -1;
+	}
+
+	return s;
+}
+
+
+#endif /* CONFIG_CLIENT_MLME */
+
+static int wpa_driver_awext_pmksa(struct wpa_driver_awext_data *drv,
+				 u32 cmd, const u8 *bssid, const u8 *pmkid)
+{
+	struct iwreq iwr;
+	struct iw_pmksa pmksa;
+	int ret = 0;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	os_memset(&pmksa, 0, sizeof(pmksa));
+	pmksa.cmd = cmd;
+	pmksa.bssid.sa_family = ARPHRD_ETHER;
+	if (bssid)
+		os_memcpy(pmksa.bssid.sa_data, bssid, ETH_ALEN);
+	if (pmkid)
+		os_memcpy(pmksa.pmkid, pmkid, IW_PMKID_LEN);
+	iwr.u.data.pointer = (caddr_t) &pmksa;
+	iwr.u.data.length = sizeof(pmksa);
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWPMKSA, &iwr) < 0) {
+		if (errno != EOPNOTSUPP)
+			perror("ioctl[SIOCSIWPMKSA]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int wpa_driver_awext_add_pmkid(void *priv, const u8 *bssid,
+				     const u8 *pmkid)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_awext_pmksa(drv, IW_PMKSA_ADD, bssid, pmkid);
+}
+
+
+static int wpa_driver_awext_remove_pmkid(void *priv, const u8 *bssid,
+		 			const u8 *pmkid)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_awext_pmksa(drv, IW_PMKSA_REMOVE, bssid, pmkid);
+}
+
+
+static int wpa_driver_awext_flush_pmkid(void *priv)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_awext_pmksa(drv, IW_PMKSA_FLUSH, NULL, NULL);
+}
+
+
+static int wpa_driver_awext_get_capa(void *priv, struct wpa_driver_capa *capa)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	if (!drv->wext->has_capability)
+		return -1;
+	os_memcpy(capa, &drv->wext->capa, sizeof(*capa));
+	return 0;
+}
+
+
+static int wpa_driver_awext_set_param(void *priv, const char *param)
+{
+#ifdef CONFIG_CLIENT_MLME
+	struct wpa_driver_awext_data *drv = priv;
+	const char *pos, *pos2;
+	size_t len;
+
+	if (param == NULL)
+		return 0;
+
+	wpa_printf(MSG_DEBUG, "%s: param='%s'", __func__, param);
+
+	pos = os_strstr(param, "mlmedev=");
+	if (pos) {
+		pos += 8;
+		pos2 = os_strchr(pos, ' ');
+		if (pos2)
+			len = pos2 - pos;
+		else
+			len = os_strlen(pos);
+		if (len + 1 > sizeof(drv->wext->mlmedev))
+			return -1;
+		os_memcpy(drv->wext->mlmedev, pos, len);
+		drv->wext->mlmedev[len] = '\0';
+		wpa_printf(MSG_DEBUG, "WEXT: Using user space MLME with "
+			   "mlmedev='%s'", drv->wext->mlmedev);
+		drv->wext->capa.flags |= WPA_DRIVER_FLAGS_USER_SPACE_MLME;
+
+		drv->wext->mlme_sock = wpa_driver_awext_open_mlme(drv->wext);
+		if (drv->wext->mlme_sock < 0)
+			return -1;
+	}
+#endif /* CONFIG_CLIENT_MLME */
+
+	return 0;
+}
+
+static int wpa_driver_awext_deauthenticate(void *priv, const u8 *addr,
+					  int reason_code)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	return wpa_driver_awext_mlme(drv, addr, IW_MLME_DEAUTH, reason_code);
+}
+
+static int wpa_driver_awext_disassociate(void *priv, const u8 *addr,
+					int reason_code)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	return wpa_driver_awext_mlme(drv, addr, IW_MLME_DISASSOC,
+				    reason_code);
+}
+
+int wpa_driver_awext_get_bssid(void *priv, u8 *bssid)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_wext_get_bssid(drv->wext, bssid);
+}
+
+int wpa_driver_awext_set_bssid(void *priv, const u8 *bssid)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_wext_set_bssid(drv->wext, bssid);
+}
+
+int wpa_driver_awext_get_ssid(void *priv, u8 *ssid)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_wext_get_ssid(drv->wext, ssid);
+}
+
+int wpa_driver_awext_set_ssid(void *priv, const u8 *ssid, size_t ssid_len)
+{
+	struct wpa_driver_awext_data *drv = priv;
+
+	if (ssid_len > 32)
+		return -1;
+
+	os_memset(drv->ssid, 0, 32);
+	os_memcpy(drv->ssid, ssid, ssid_len);
+	drv->ssid_len = ssid_len;
+
+	return wpa_driver_wext_set_ssid(drv->wext, ssid, ssid_len);
+}
+
+int wpa_driver_awext_set_freq(void *priv, int freq)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_wext_set_freq(drv->wext, freq);
+}
+
+int wpa_driver_awext_get_ifflags(void *priv, int *flags)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_wext_get_ifflags(drv->wext, flags);
+}
+
+int wpa_driver_awext_set_ifflags(struct wpa_driver_awext_data *drv, int flags)
+{
+	return wpa_driver_wext_set_ifflags(drv->wext, flags);
+}
+
+void * wpa_driver_awext_init(void *ctx, const char *ifname)
+{
+	struct wpa_driver_awext_data *drv;
+	drv = os_zalloc(sizeof(*drv));
+	if (drv == NULL)
+		return NULL;
+	drv->wext = wpa_driver_wext_init(ctx, ifname);
+	if (drv->wext == NULL)
+	{
+		os_free(drv);
+		return NULL;
+	}
+
+	drv->ctx = ctx;
+
+	os_strncpy(drv->ifname, ifname, sizeof(drv->ifname));
+	drv->ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
+	if (drv->ioctl_sock < 0)
+	{
+		wpa_driver_wext_deinit(drv->wext);
+		os_free(drv);
+		return NULL;
+	}
+
+	return drv;
+}
+
+void wpa_driver_awext_deinit(void *priv)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	wpa_driver_wext_deinit(drv->wext);
+	close(drv->ioctl_sock);
+	os_free(drv);
+}
+
+void wpa_driver_awext_scan_timeout(void *eloop_ctx, void *timeout_ctx)
+{
+	return wpa_driver_wext_scan_timeout(eloop_ctx, timeout_ctx);
+}
+
+int wpa_driver_awext_scan(void *priv, const u8 *ssid, size_t ssid_len)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_wext_scan(drv->wext, ssid, ssid_len);
+}
+
+int wpa_driver_awext_get_scan_results(void *priv,
+				     struct wpa_scan_result *results,
+				     size_t max_size)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_wext_get_scan_results(drv->wext, results, max_size);
+}
+
+int wpa_driver_awext_set_key(void *priv, wpa_alg alg,
+			    const u8 *addr, int key_idx,
+			    int set_tx, const u8 *seq, size_t seq_len,
+			    const u8 *key, size_t key_len)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_wext_set_key(drv->wext, alg, addr, key_idx, set_tx, seq, seq_len, key, key_len);
+}
+
+int wpa_driver_awext_set_mode(void *priv, int mode)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_wext_set_mode(drv->wext, mode);
+}
+
+int wpa_driver_awext_alternative_ifindex(struct wpa_driver_awext_data *drv,
+					const char *ifname)
+{
+	return wpa_driver_wext_alternative_ifindex(drv->wext, ifname);
+}
+
+int wpa_driver_awext_set_operstate(void *priv, int state)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_wext_set_operstate(drv->wext, state);
+}
+
+int wpa_driver_awext_set_channel(void *priv, wpa_hw_mode phymode, int chan,
+				int freq)
+{
+	struct wpa_driver_awext_data *drv = priv;
+	return wpa_driver_awext_set_freq(drv->wext, freq);
+}
+
+int wpa_driver_awext_get_version(struct wpa_driver_awext_data *drv)
+{
+	return wpa_driver_wext_get_version(drv->wext);
+}
+
+int wpa_driver_awext_set_wpa(void *priv, int enabled)
+{
+    struct wpa_driver_awext_data *drv = priv;
+    return wpa_driver_awext_set_auth_param(drv, IW_AUTH_WPA_ENABLED, enabled);
+}
+
+#ifdef ANDROID
+static int wpa_driver_priv_driver_cmd(void *priv, char *cmd, char *buf, size_t buf_len)
+{
+
+	struct wpa_driver_awext_data *drv = priv;
+	int ret = -1;
+	int flags;
+
+	wpa_printf(MSG_DEBUG, "AWEXT: %s %s", __func__, cmd);
+
+	if (os_strcasecmp(cmd, "start") == 0) {
+		wpa_printf(MSG_DEBUG,"Start command");
+		return (ret);
+	}
+
+	if (os_strcasecmp(cmd, "stop") == 0) {
+		wpa_printf(MSG_DEBUG,"Stop command");
+		if ((wpa_driver_awext_get_ifflags(drv, &flags) == 0) &&
+		    (flags & IFF_UP)) {
+			wpa_printf(MSG_ERROR, "WEXT: %s when iface is UP", cmd);
+			wpa_driver_awext_set_ifflags(drv, flags & ~IFF_UP);
+		}
+
+	}
+	else if (os_strcasecmp(cmd, "reload") == 0) {
+		wpa_printf(MSG_DEBUG,"Reload command");
+		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+		return ret;
+	}
+	else if (os_strcasecmp(cmd, "macaddr") == 0) {
+		struct ifreq ifr;
+		os_memset(&ifr, 0, sizeof(ifr));
+		os_strncpy(ifr.ifr_name, drv->ifname, IFNAMSIZ);
+
+		if (ioctl(drv->ioctl_sock, SIOCGIFHWADDR, &ifr) < 0) {
+			perror("ioctl[SIOCGIFHWADDR]");
+			ret = -1;
+		} else {
+			u8 *macaddr = (u8 *) ifr.ifr_hwaddr.sa_data;
+			ret = snprintf(buf, buf_len, "Macaddr = " MACSTR "\n",
+			               MAC2STR(macaddr));
+		}
+	}
+	else if (os_strcasecmp(cmd, "scan-passive") == 0) {
+		wpa_printf(MSG_DEBUG,"Scan Passive command");
+	}
+	else if (os_strcasecmp(cmd, "scan-active") == 0) {
+		wpa_printf(MSG_DEBUG,"Scan Active command");
+	}
+	else if (os_strcasecmp(cmd, "linkspeed") == 0) {
+		struct iwreq wrq;
+		unsigned int linkspeed;
+		os_strncpy(wrq.ifr_name, drv->ifname, IFNAMSIZ);
+		wpa_printf(MSG_DEBUG,"Link Speed command");
+		if (ioctl(drv->ioctl_sock, SIOCGIWRATE, &wrq) < 0) {
+			perror("ioctl[SIOCGIWRATE]");
+			ret = -1;
+		} else {
+			linkspeed = wrq.u.bitrate.value / 1000000;
+			ret = snprintf(buf, buf_len, "LinkSpeed %d\n", linkspeed);
+		}
+	}
+	else if (os_strncasecmp(cmd, "scan-channels", 13) == 0) {
+	}
+	else if ((os_strcasecmp(cmd, "rssi") == 0) || (os_strcasecmp(cmd, "rssi-approx") == 0)) {
+		struct iwreq wrq;
+		struct iw_statistics stats;
+		signed int rssi;
+		wpa_printf(MSG_DEBUG, ">>>. DRIVER AWEXT RSSI ");
+		wrq.u.data.pointer = (caddr_t) &stats;
+		wrq.u.data.length = sizeof(stats);
+		wrq.u.data.flags = 1; /* Clear updated flag */
+		strncpy(wrq.ifr_name, drv->ifname, IFNAMSIZ);
+
+		if (ioctl(drv->ioctl_sock, SIOCGIWSTATS, &wrq) < 0) {
+			perror("ioctl[SIOCGIWSTATS]");
+			ret = -1;
+		} else {
+			if (stats.qual.updated & IW_QUAL_DBM) {
+				/* Values in dBm, stored in u8 with range 63 : -192 */
+				rssi = ( stats.qual.level > 63 ) ?
+					stats.qual.level - 0x100 :
+					stats.qual.level;
+			} else {
+				rssi = stats.qual.level;
+			}
+
+			if (drv->ssid_len != 0 && drv->ssid_len < buf_len) {
+				os_memcpy((void *) buf, (void *) (drv->ssid),
+						drv->ssid_len );
+				ret = drv->ssid_len;
+				ret += snprintf(&buf[ret], buf_len-ret,
+						" rssi %d\n", rssi);
+				if (ret < (int)buf_len) {
+					return( ret );
+				}
+				ret = -1;
+			}
+		}
+	}
+	else if (os_strncasecmp(cmd, "powermode", 9) == 0) {
+	}
+	else if (os_strncasecmp(cmd, "getpower", 8) == 0) {
+	}
+	else if (os_strncasecmp(cmd, "get-rts-threshold", 17) == 0) {
+		struct iwreq wrq;
+		unsigned int rtsThreshold;
+
+		strncpy(wrq.ifr_name, drv->ifname, IFNAMSIZ);
+
+		if (ioctl(drv->ioctl_sock, SIOCGIWRTS, &wrq) < 0) {
+			perror("ioctl[SIOCGIWRTS]");
+			ret = -1;
+		} else {
+			rtsThreshold = wrq.u.rts.value;
+			wpa_printf(MSG_DEBUG,"Get RTS Threshold command = %d",
+				rtsThreshold);
+			ret = snprintf(buf, buf_len, "rts-threshold = %u\n",
+				rtsThreshold);
+			if (ret < (int)buf_len) {
+				return( ret );
+			}
+		}
+	}
+	else if (os_strncasecmp(cmd, "set-rts-threshold", 17) == 0) {
+		struct iwreq wrq;
+		unsigned int rtsThreshold;
+		char *cp = cmd + 17;
+		char *endp;
+
+		strncpy(wrq.ifr_name, drv->ifname, IFNAMSIZ);
+
+		if (*cp != '\0') {
+			rtsThreshold = (unsigned int)strtol(cp, &endp, 0);
+		if (endp != cp) {
+				wrq.u.rts.value = rtsThreshold;
+				wrq.u.rts.fixed = 1;
+				wrq.u.rts.disabled = 0;
+
+				if (ioctl(drv->ioctl_sock, SIOCSIWRTS, &wrq) < 0) {
+					perror("ioctl[SIOCGIWRTS]");
+					ret = -1;
+				} else {
+					rtsThreshold = wrq.u.rts.value;
+					wpa_printf(MSG_DEBUG,"Set RTS Threshold command = %d", rtsThreshold);
+					ret = 0;
+				}
+			}
+		}
+	}
+	else if (os_strcasecmp(cmd, "btcoexscan-start") == 0) {
+	}
+	else if (os_strcasecmp(cmd, "btcoexscan-stop") == 0) {
+	}
+	else if (os_strcasecmp(cmd, "rxfilter-start") == 0) {
+		wpa_printf(MSG_DEBUG,"Rx Data Filter Start command");
+	}
+	else if (os_strcasecmp(cmd, "rxfilter-stop") == 0) {
+		wpa_printf(MSG_DEBUG,"Rx Data Filter Stop command");
+	}
+	else if (os_strcasecmp(cmd, "rxfilter-statistics") == 0) {
+	}
+	else if (os_strncasecmp(cmd, "rxfilter-add", 12) == 0 ) {
+	}
+	else if (os_strncasecmp(cmd, "rxfilter-remove",15) == 0) {
+	}
+	else if (os_strcasecmp(cmd, "snr") == 0) {
+		struct iwreq wrq;
+		struct iw_statistics stats;
+		int snr, rssi, noise;
+
+		wrq.u.data.pointer = (caddr_t) &stats;
+		wrq.u.data.length = sizeof(stats);
+		wrq.u.data.flags = 1; /* Clear updated flag */
+		strncpy(wrq.ifr_name, drv->ifname, IFNAMSIZ);
+
+		if (ioctl(drv->ioctl_sock, SIOCGIWSTATS, &wrq) < 0) {
+			perror("ioctl[SIOCGIWSTATS]");
+			ret = -1;
+		} else {
+			if (stats.qual.updated & IW_QUAL_DBM) {
+				/* Values in dBm, stored in u8 with range 63 : -192 */
+				rssi = ( stats.qual.level > 63 ) ?
+					stats.qual.level - 0x100 :
+					stats.qual.level;
+				noise = ( stats.qual.noise > 63 ) ?
+					stats.qual.noise - 0x100 :
+					stats.qual.noise;
+			} else {
+				rssi = stats.qual.level;
+				noise = stats.qual.noise;
+			}
+
+			snr = rssi - noise;
+
+			ret = snprintf(buf, buf_len, "snr = %u\n", (unsigned int)snr);
+			if (ret < (int)buf_len) {
+				return( ret );
+			}
+		}
+	}
+	else if (os_strncasecmp(cmd, "btcoexmode", 10) == 0) {
+	}
+	else if( os_strcasecmp(cmd, "btcoexstat") == 0 ) {
+	}
+	else {
+		wpa_printf(MSG_DEBUG,"Unsupported command");
+	}
+	return (ret);
+}
+#endif
+
+const struct wpa_driver_ops wpa_driver_awext_ops = {
+	.name = "awext",
+	.desc = "Android wireless extensions emulation",
+	.get_bssid = wpa_driver_awext_get_bssid,
+	.get_ssid = wpa_driver_awext_get_ssid,
+	.set_wpa = wpa_driver_awext_set_wpa,
+	.set_key = wpa_driver_awext_set_key,
+	.set_countermeasures = wpa_driver_awext_set_countermeasures,
+	.set_drop_unencrypted = wpa_driver_awext_set_drop_unencrypted,
+	.scan = wpa_driver_awext_scan,
+	.get_scan_results = wpa_driver_awext_get_scan_results,
+	.deauthenticate = wpa_driver_awext_deauthenticate,
+	.disassociate = wpa_driver_awext_disassociate,
+	.associate = wpa_driver_awext_associate,
+	.set_auth_alg = wpa_driver_awext_set_auth_alg,
+	.init = wpa_driver_awext_init,
+	.deinit = wpa_driver_awext_deinit,
+
+	.set_param = wpa_driver_awext_set_param,
+	.add_pmkid = wpa_driver_awext_add_pmkid,
+	.remove_pmkid = wpa_driver_awext_remove_pmkid,
+	.flush_pmkid = wpa_driver_awext_flush_pmkid,
+	.get_capa = wpa_driver_awext_get_capa,
+	.set_operstate = wpa_driver_awext_set_operstate,
+#ifdef CONFIG_CLIENT_MLME
+	.get_hw_feature_data = wpa_driver_awext_get_hw_feature_data,
+	.set_channel = wpa_driver_awext_set_channel,
+	.set_ssid = wpa_driver_awext_set_ssid,
+	.set_bssid = wpa_driver_awext_set_bssid,
+	.send_mlme = wpa_driver_awext_send_mlme,
+	.mlme_add_sta = wpa_driver_awext_mlme_add_sta,
+	.mlme_remove_sta = wpa_driver_awext_mlme_remove_sta,
+#endif /* CONFIG_CLIENT_MLME */
+#ifdef ANDROID
+	.driver_cmd = wpa_driver_priv_driver_cmd,
+#endif
+};
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/driver_awext.h /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/driver_awext.h
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/driver_awext.h	1970-01-01 07:00:00.000000000 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/driver_awext.h	2012-11-21 23:02:38.000000000 +0700
@@ -0,0 +1,88 @@
+/*
+ * WPA Supplicant - driver_wext exported functions
+ * Copyright (c) 2003-2005, Jouni Malinen <j@w1.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Alternatively, this software may be distributed under the terms of BSD
+ * license.
+ *
+ * See README and COPYING for more details.
+ */
+
+#ifndef DRIVER_AWEXT_H
+#define DRIVER_AWEXT_H
+
+#include "driver_wext.h"
+
+struct wpa_driver_wext_data {
+	void *ctx;
+	int event_sock;
+	int ioctl_sock;
+	int mlme_sock;
+	char ifname[IFNAMSIZ + 1];
+	int ifindex;
+	int ifindex2;
+	int if_removed;
+	u8 *assoc_req_ies;
+	size_t assoc_req_ies_len;
+	u8 *assoc_resp_ies;
+	size_t assoc_resp_ies_len;
+	struct wpa_driver_capa capa;
+	int has_capability;
+	int we_version_compiled;
+
+	/* for set_auth_alg fallback */
+	int use_crypt;
+	int auth_alg_fallback;
+
+	int operstate;
+
+	char mlmedev[IFNAMSIZ + 1];
+
+	int scan_complete_events;
+	int errors;
+};
+
+struct wpa_driver_awext_data;
+
+int wpa_driver_awext_get_ifflags(void *priv, int *flags);
+int wpa_driver_awext_set_ifflags(struct wpa_driver_awext_data *drv, int flags);
+int wpa_driver_awext_get_bssid(void *priv, u8 *bssid);
+int wpa_driver_awext_set_bssid(void *priv, const u8 *bssid);
+int wpa_driver_awext_get_ssid(void *priv, u8 *ssid);
+int wpa_driver_awext_set_ssid(void *priv, const u8 *ssid, size_t ssid_len);
+int wpa_driver_awext_set_freq(void *priv, int freq);
+int wpa_driver_awext_set_mode(void *priv, int mode);
+int wpa_driver_awext_set_key(void *priv, wpa_alg alg,
+			    const u8 *addr, int key_idx,
+			    int set_tx, const u8 *seq, size_t seq_len,
+			    const u8 *key, size_t key_len);
+int wpa_driver_awext_scan(void *priv, const u8 *ssid, size_t ssid_len);
+int wpa_driver_awext_get_scan_results(void *priv,
+				     struct wpa_scan_result *results,
+				     size_t max_size);
+
+void wpa_driver_awext_scan_timeout(void *eloop_ctx, void *timeout_ctx);
+
+int wpa_driver_awext_alternative_ifindex(struct wpa_driver_awext_data *drv,
+					const char *ifname);
+
+void * wpa_driver_awext_init(void *ctx, const char *ifname);
+void wpa_driver_awext_deinit(void *priv);
+
+int wpa_driver_awext_set_operstate(void *priv, int state);
+int wpa_driver_awext_get_version(struct wpa_driver_awext_data *drv);
+
+#ifdef ANDROID
+#define WEXT_NUMBER_SCAN_CHANNELS_FCC	11
+#define WEXT_NUMBER_SCAN_CHANNELS_ETSI	13
+#define WEXT_NUMBER_SCAN_CHANNELS_MKK1	14
+
+#define WPA_DRIVER_WEXT_WAIT_US		400000
+#define MAX_DRV_CMD_SIZE		248
+#endif
+
+#endif /* DRIVER_AWEXT_H */
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/drivers.c /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/drivers.c
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/drivers.c	2012-11-19 12:58:30.773108202 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/drivers.c	2012-11-21 22:54:35.000000000 +0700
@@ -14,10 +14,13 @@
 
 #include "includes.h"
 
-
+#ifdef CONFIG_DRIVER_AWEXT
+extern struct wpa_driver_ops wpa_driver_awext_ops; /* driver_awext.c */
+#else
 #ifdef CONFIG_DRIVER_WEXT
 extern struct wpa_driver_ops wpa_driver_wext_ops; /* driver_wext.c */
 #endif /* CONFIG_DRIVER_WEXT */
+#endif /* CONFIG_DRIVER_AWEXT */
 #ifdef CONFIG_DRIVER_HOSTAP
 extern struct wpa_driver_ops wpa_driver_hostap_ops; /* driver_hostap.c */
 #endif /* CONFIG_DRIVER_HOSTAP */
@@ -62,9 +65,13 @@ extern struct wpa_driver_ops wpa_driver_
 
 struct wpa_driver_ops *wpa_supplicant_drivers[] =
 {
+#ifdef CONFIG_DRIVER_AWEXT
+	&wpa_driver_awext_ops,
+#else
 #ifdef CONFIG_DRIVER_WEXT
 	&wpa_driver_wext_ops,
 #endif /* CONFIG_DRIVER_WEXT */
+#endif /* CONFIG_DRIVER_AWEXT */
 #ifdef CONFIG_DRIVER_HOSTAP
 	&wpa_driver_hostap_ops,
 #endif /* CONFIG_DRIVER_HOSTAP */
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/driver_wext.c /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/driver_wext.c
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/driver_wext.c	2012-11-19 12:58:30.797108201 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/driver_wext.c	2012-11-21 16:37:44.508150352 +0700
@@ -84,7 +84,6 @@ struct wpa_driver_wext_data {
 	char mlmedev[IFNAMSIZ + 1];
 
 	int scan_complete_events;
-	int errors;
 };
 
 
@@ -1002,7 +1001,6 @@ void * wpa_driver_wext_init(void *ctx, c
 
 	drv->mlme_sock = -1;
 
-	drv->errors = 0;
 	wpa_driver_wext_finish_drv_init(drv);
 
 	return drv;
@@ -1396,8 +1394,17 @@ int wpa_driver_wext_get_scan_results(voi
 		case IWEVQUAL:
 			if (ap_num < max_size) {
 				results[ap_num].qual = iwe->u.qual.qual;
-				results[ap_num].noise = iwe->u.qual.noise;
-				results[ap_num].level = iwe->u.qual.level;
+				if( iwe->u.qual.updated & IW_QUAL_DBM )
+				{
+					/* Values in dBm, stored in u8 with range 63 : -192 */
+					results[ap_num].noise = ( iwe->u.qual.noise > 63 ) ? iwe->u.qual.noise - 0x100 : iwe->u.qual.noise;
+					results[ap_num].level = ( iwe->u.qual.level > 63 ) ? iwe->u.qual.level - 0x100 : iwe->u.qual.level;
+				}
+				else
+				{
+					results[ap_num].noise = iwe->u.qual.noise;
+					results[ap_num].level = iwe->u.qual.level;
+				}
 			}
 			break;
 		case SIOCGIWENCODE:
@@ -2544,15 +2551,11 @@ static int wpa_driver_priv_driver_cmd(vo
 	else if (os_strcasecmp(cmd, "STOP") == 0) {
 		if ((wpa_driver_wext_get_ifflags(drv, &flags) == 0) &&
 		    (flags & IFF_UP)) {
-			wpa_printf(MSG_ERROR, "WEXT: %s when iface is UP", cmd);
+			wpa_printf(MSG_ERROR, "WEXT: %s when iface is UP",
+				cmd);
 			wpa_driver_wext_set_ifflags(drv, flags & ~IFF_UP);
 		}
 	}
-	else if( os_strcasecmp(cmd, "RELOAD") == 0 ) {
-		wpa_printf(MSG_DEBUG,"Reload command");
-		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
-		return ret;
-	}
 
 	os_memset(&iwr, 0, sizeof(iwr));
 	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
@@ -2564,16 +2567,9 @@ static int wpa_driver_priv_driver_cmd(vo
 		perror("ioctl[SIOCSIWPRIV]");
 	}
 
-	if (ret < 0) {
+	if (ret < 0)
 		wpa_printf(MSG_ERROR, "%s failed", __func__);
-		drv->errors++;
-		if (drv->errors > WEXT_NUMBER_SEQUENTIAL_ERRORS) {
-			drv->errors = 0;
-			wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
-		}
-	}
 	else {
-		drv->errors = 0;
 		ret = 0;
 		if ((os_strcasecmp(cmd, "RSSI") == 0) ||
 		    (os_strcasecmp(cmd, "LINKSPEED") == 0) ||
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/driver_wext.h /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/driver_wext.h
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/driver_wext.h	2012-11-19 12:58:30.805108201 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/driver_wext.h	2012-11-21 16:37:44.515150352 +0700
@@ -52,7 +52,6 @@ int wpa_driver_wext_get_version(struct w
 
 #define WPA_DRIVER_WEXT_WAIT_US		400000
 #define MAX_DRV_CMD_SIZE		248
-#define WEXT_NUMBER_SEQUENTIAL_ERRORS	4
 #endif
 
 #endif /* DRIVER_WEXT_H */
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/HEAD /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/HEAD
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/HEAD	2012-11-19 12:58:30.921108207 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/HEAD	2012-11-21 16:32:19.742169710 +0700
@@ -1 +1 @@
-2b7ee495307e9fd349a0f37ec560834adbc954cc
+ref: refs/heads/imx_r10.3
Binary files /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/index and /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/index differ
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/logs/HEAD /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/logs/HEAD
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/logs/HEAD	1970-01-01 07:00:00.000000000 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/logs/HEAD	2012-11-21 16:37:44.534150351 +0700
@@ -0,0 +1,4 @@
+2b7ee495307e9fd349a0f37ec560834adbc954cc 2b7ee495307e9fd349a0f37ec560834adbc954cc phuong <phuong@mail.com> 1353490339 +0700	checkout: moving from 2b7ee495307e9fd349a0f37ec560834adbc954cc to imx_r10.3
+2b7ee495307e9fd349a0f37ec560834adbc954cc c17152e31c6ec33b297e62e0d721edc5148f6687 phuong <phuong@mail.com> 1353490664 +0700	quiltimport: 0001-Add-CSR-Unifi-support.patch
+c17152e31c6ec33b297e62e0d721edc5148f6687 e57561f8c807563a9a0c684966b51c58170d3e83 phuong <phuong@mail.com> 1353490664 +0700	quiltimport: 0002-Update-Android.mk-to-install-wpa_supplicant.conf.patch
+e57561f8c807563a9a0c684966b51c58170d3e83 16a37673eb24d050d2227035ec57c3e6e1c1445f phuong <phuong@mail.com> 1353490664 +0700	quiltimport: 0003-Revert-driver_wext-Add-HANGED-processing-b-2310372-D.patch
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/logs/refs/heads/imx_r10.3 /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/logs/refs/heads/imx_r10.3
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/logs/refs/heads/imx_r10.3	1970-01-01 07:00:00.000000000 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/logs/refs/heads/imx_r10.3	2012-11-21 16:37:44.534150351 +0700
@@ -0,0 +1,4 @@
+0000000000000000000000000000000000000000 2b7ee495307e9fd349a0f37ec560834adbc954cc phuong <phuong@mail.com> 1353490339 +0700	branch: Created from 2b7ee495307e9fd349a0f37ec560834adbc954cc
+2b7ee495307e9fd349a0f37ec560834adbc954cc c17152e31c6ec33b297e62e0d721edc5148f6687 phuong <phuong@mail.com> 1353490664 +0700	quiltimport: 0001-Add-CSR-Unifi-support.patch
+c17152e31c6ec33b297e62e0d721edc5148f6687 e57561f8c807563a9a0c684966b51c58170d3e83 phuong <phuong@mail.com> 1353490664 +0700	quiltimport: 0002-Update-Android.mk-to-install-wpa_supplicant.conf.patch
+e57561f8c807563a9a0c684966b51c58170d3e83 16a37673eb24d050d2227035ec57c3e6e1c1445f phuong <phuong@mail.com> 1353490664 +0700	quiltimport: 0003-Revert-driver_wext-Add-HANGED-processing-b-2310372-D.patch
Binary files /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/objects/16/a37673eb24d050d2227035ec57c3e6e1c1445f and /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/objects/16/a37673eb24d050d2227035ec57c3e6e1c1445f differ
Binary files /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/objects/24/e63092d02096d1975d3c152bb19da78fd5529b and /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/objects/24/e63092d02096d1975d3c152bb19da78fd5529b differ
Binary files /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/objects/24/fb86c752946b212acb5a03af7d685f09398109 and /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/objects/24/fb86c752946b212acb5a03af7d685f09398109 differ
Binary files /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/objects/53/6636f79e0b790f1f7e021c4f64abfaac99ee69 and /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/objects/53/6636f79e0b790f1f7e021c4f64abfaac99ee69 differ
Binary files /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/objects/73/0e184986d1a5ff61e7ac52b803dba486e60d23 and /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/objects/73/0e184986d1a5ff61e7ac52b803dba486e60d23 differ
Binary files /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/objects/93/caf18605b16032ebf8cc210a8f7989321dc5ff and /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/objects/93/caf18605b16032ebf8cc210a8f7989321dc5ff differ
Binary files /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/objects/b6/dee283368eed651183378ff98554eb2fe9cec0 and /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/objects/b6/dee283368eed651183378ff98554eb2fe9cec0 differ
Binary files /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/objects/c1/7152e31c6ec33b297e62e0d721edc5148f6687 and /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/objects/c1/7152e31c6ec33b297e62e0d721edc5148f6687 differ
Binary files /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/objects/e5/7561f8c807563a9a0c684966b51c58170d3e83 and /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/objects/e5/7561f8c807563a9a0c684966b51c58170d3e83 differ
Binary files /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/objects/fe/c3e3c9bbf50d70da27d979cfc1e3e4935284ab and /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/objects/fe/c3e3c9bbf50d70da27d979cfc1e3e4935284ab differ
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/refs/heads/imx_r10.3 /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/refs/heads/imx_r10.3
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/.git/refs/heads/imx_r10.3	1970-01-01 07:00:00.000000000 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/.git/refs/heads/imx_r10.3	2012-11-21 16:37:44.534150351 +0700
@@ -0,0 +1 @@
+16a37673eb24d050d2227035ec57c3e6e1c1445f
diff -rupN /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/wpa_supplicant.conf /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/wpa_supplicant.conf
--- /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src-orig/external/wpa_supplicant/wpa_supplicant.conf	2012-11-19 12:58:30.671108205 +0700
+++ /home/vuarm/working/android/imx535/sources/i.MX53-QSB-Android-Gingerbread-Release4.3/src/external/wpa_supplicant/wpa_supplicant.conf	2012-11-22 08:59:58.000000000 +0700
@@ -1,747 +1,6 @@
-##### Example wpa_supplicant configuration file ###############################
-#
-# This file describes configuration file format and lists all available option.
-# Please also take a look at simpler configuration examples in 'examples'
-# subdirectory.
-#
-# Empty lines and lines starting with # are ignored
-
-# NOTE! This file may contain password information and should probably be made
-# readable only by root user on multiuser systems.
-
-# Note: All file paths in this configuration file should use full (absolute,
-# not relative to working directory) path in order to allow working directory
-# to be changed. This can happen if wpa_supplicant is run in the background.
-
-# Whether to allow wpa_supplicant to update (overwrite) configuration
-#
-# This option can be used to allow wpa_supplicant to overwrite configuration
-# file whenever configuration is changed (e.g., new network block is added with
-# wpa_cli or wpa_gui, or a password is changed). This is required for
-# wpa_cli/wpa_gui to be able to store the configuration changes permanently.
-# Please note that overwriting configuration file will remove the comments from
-# it.
+ctrl_interface=DIR=/data/misc/wifi/wpa_supplicant GROUP=wifi
 update_config=1
-
-# global configuration (shared by all network blocks)
-#
-# Parameters for the control interface. If this is specified, wpa_supplicant
-# will open a control interface that is available for external programs to
-# manage wpa_supplicant. The meaning of this string depends on which control
-# interface mechanism is used. For all cases, the existance of this parameter
-# in configuration is used to determine whether the control interface is
-# enabled.
-#
-# For UNIX domain sockets (default on Linux and BSD): This is a directory that
-# will be created for UNIX domain sockets for listening to requests from
-# external programs (CLI/GUI, etc.) for status information and configuration.
-# The socket file will be named based on the interface name, so multiple
-# wpa_supplicant processes can be run at the same time if more than one
-# interface is used.
-# /var/run/wpa_supplicant is the recommended directory for sockets and by
-# default, wpa_cli will use it when trying to connect with wpa_supplicant.
-#
-# Access control for the control interface can be configured by setting the
-# directory to allow only members of a group to use sockets. This way, it is
-# possible to run wpa_supplicant as root (since it needs to change network
-# configuration and open raw sockets) and still allow GUI/CLI components to be
-# run as non-root users. However, since the control interface can be used to
-# change the network configuration, this access needs to be protected in many
-# cases. By default, wpa_supplicant is configured to use gid 0 (root). If you
-# want to allow non-root users to use the control interface, add a new group
-# and change this value to match with that group. Add users that should have
-# control interface access to this group. If this variable is commented out or
-# not included in the configuration file, group will not be changed from the
-# value it got by default when the directory or socket was created.
-#
-# When configuring both the directory and group, use following format:
-# DIR=/var/run/wpa_supplicant GROUP=wheel
-# DIR=/var/run/wpa_supplicant GROUP=0
-# (group can be either group name or gid)
-#
-# For UDP connections (default on Windows): The value will be ignored. This
-# variable is just used to select that the control interface is to be created.
-# The value can be set to, e.g., udp (ctrl_interface=udp)
-#
-# For Windows Named Pipe: This value can be used to set the security descriptor
-# for controlling access to the control interface. Security descriptor can be
-# set using Security Descriptor String Format (see http://msdn.microsoft.com/
-# library/default.asp?url=/library/en-us/secauthz/security/
-# security_descriptor_string_format.asp). The descriptor string needs to be
-# prefixed with SDDL=. For example, ctrl_interface=SDDL=D: would set an empty
-# DACL (which will reject all connections). See README-Windows.txt for more
-# information about SDDL string format.
-#
-ctrl_interface=wlan0
-
-# IEEE 802.1X/EAPOL version
-# wpa_supplicant is implemented based on IEEE Std 802.1X-2004 which defines
-# EAPOL version 2. However, there are many APs that do not handle the new
-# version number correctly (they seem to drop the frames completely). In order
-# to make wpa_supplicant interoperate with these APs, the version number is set
-# to 1 by default. This configuration value can be used to set it to the new
-# version (2).
 eapol_version=1
-
-# AP scanning/selection
-# By default, wpa_supplicant requests driver to perform AP scanning and then
-# uses the scan results to select a suitable AP. Another alternative is to
-# allow the driver to take care of AP scanning and selection and use
-# wpa_supplicant just to process EAPOL frames based on IEEE 802.11 association
-# information from the driver.
-# 1: wpa_supplicant initiates scanning and AP selection
-# 0: driver takes care of scanning, AP selection, and IEEE 802.11 association
-#    parameters (e.g., WPA IE generation); this mode can also be used with
-#    non-WPA drivers when using IEEE 802.1X mode; do not try to associate with
-#    APs (i.e., external program needs to control association). This mode must
-#    also be used when using wired Ethernet drivers.
-# 2: like 0, but associate with APs using security policy and SSID (but not
-#    BSSID); this can be used, e.g., with ndiswrapper and NDIS drivers to
-#    enable operation with hidden SSIDs and optimized roaming; in this mode,
-#    the network blocks in the configuration file are tried one by one until
-#    the driver reports successful association; each network block should have
-#    explicit security policy (i.e., only one option in the lists) for
-#    key_mgmt, pairwise, group, proto variables
 ap_scan=1
-
-# EAP fast re-authentication
-# By default, fast re-authentication is enabled for all EAP methods that
-# support it. This variable can be used to disable fast re-authentication.
-# Normally, there is no need to disable this.
 fast_reauth=1
 
-# OpenSSL Engine support
-# These options can be used to load OpenSSL engines.
-# The two engines that are supported currently are shown below:
-# They are both from the opensc project (http://www.opensc.org/)
-# By default no engines are loaded.
-# make the opensc engine available
-#opensc_engine_path=/usr/lib/opensc/engine_opensc.so
-# make the pkcs11 engine available
-#pkcs11_engine_path=/usr/lib/opensc/engine_pkcs11.so
-# configure the path to the pkcs11 module required by the pkcs11 engine
-#pkcs11_module_path=/usr/lib/pkcs11/opensc-pkcs11.so
-
-# Dynamic EAP methods
-# If EAP methods were built dynamically as shared object files, they need to be
-# loaded here before being used in the network blocks. By default, EAP methods
-# are included statically in the build, so these lines are not needed
-#load_dynamic_eap=/usr/lib/wpa_supplicant/eap_tls.so
-#load_dynamic_eap=/usr/lib/wpa_supplicant/eap_md5.so
-
-# Driver interface parameters
-# This field can be used to configure arbitrary driver interace parameters. The
-# format is specific to the selected driver interface. This field is not used
-# in most cases.
-#driver_param="field=value"
-
-# Maximum lifetime for PMKSA in seconds; default 43200
-#dot11RSNAConfigPMKLifetime=43200
-# Threshold for reauthentication (percentage of PMK lifetime); default 70
-#dot11RSNAConfigPMKReauthThreshold=70
-# Timeout for security association negotiation in seconds; default 60
-#dot11RSNAConfigSATimeout=60
-
-# network block
-#
-# Each network (usually AP's sharing the same SSID) is configured as a separate
-# block in this configuration file. The network blocks are in preference order
-# (the first match is used).
-#
-# network block fields:
-#
-# disabled:
-#	0 = this network can be used (default)
-#	1 = this network block is disabled (can be enabled through ctrl_iface,
-#	    e.g., with wpa_cli or wpa_gui)
-#
-# id_str: Network identifier string for external scripts. This value is passed
-#	to external action script through wpa_cli as WPA_ID_STR environment
-#	variable to make it easier to do network specific configuration.
-#
-# ssid: SSID (mandatory); either as an ASCII string with double quotation or
-#	as hex string; network name
-#
-# scan_ssid:
-#	0 = do not scan this SSID with specific Probe Request frames (default)
-#	1 = scan with SSID-specific Probe Request frames (this can be used to
-#	    find APs that do not accept broadcast SSID or use multiple SSIDs;
-#	    this will add latency to scanning, so enable this only when needed)
-#
-# bssid: BSSID (optional); if set, this network block is used only when
-#	associating with the AP using the configured BSSID
-#
-# priority: priority group (integer)
-# By default, all networks will get same priority group (0). If some of the
-# networks are more desirable, this field can be used to change the order in
-# which wpa_supplicant goes through the networks when selecting a BSS. The
-# priority groups will be iterated in decreasing priority (i.e., the larger the
-# priority value, the sooner the network is matched against the scan results).
-# Within each priority group, networks will be selected based on security
-# policy, signal strength, etc.
-# Please note that AP scanning with scan_ssid=1 and ap_scan=2 mode are not
-# using this priority to select the order for scanning. Instead, they try the
-# networks in the order that used in the configuration file.
-#
-# mode: IEEE 802.11 operation mode
-# 0 = infrastructure (Managed) mode, i.e., associate with an AP (default)
-# 1 = IBSS (ad-hoc, peer-to-peer)
-# Note: IBSS can only be used with key_mgmt NONE (plaintext and static WEP)
-# and key_mgmt=WPA-NONE (fixed group key TKIP/CCMP). In addition, ap_scan has
-# to be set to 2 for IBSS. WPA-None requires following network block options:
-# proto=WPA, key_mgmt=WPA-NONE, pairwise=NONE, group=TKIP (or CCMP, but not
-# both), and psk must also be set.
-#
-# frequency: Channel frequency in megahertz (MHz) for IBSS, e.g.,
-# 2412 = IEEE 802.11b/g channel 1. This value is used to configure the initial
-# channel for IBSS (adhoc) networks. It is ignored in the infrastructure mode.
-# In addition, this value is only used by the station that creates the IBSS. If
-# an IBSS network with the configured SSID is already present, the frequency of
-# the network will be used instead of this configured value.
-#
-# proto: list of accepted protocols
-# WPA = WPA/IEEE 802.11i/D3.0
-# RSN = WPA2/IEEE 802.11i (also WPA2 can be used as an alias for RSN)
-# If not set, this defaults to: WPA RSN
-#
-# key_mgmt: list of accepted authenticated key management protocols
-# WPA-PSK = WPA pre-shared key (this requires 'psk' field)
-# WPA-EAP = WPA using EAP authentication (this can use an external
-#	program, e.g., Xsupplicant, for IEEE 802.1X EAP Authentication
-# IEEE8021X = IEEE 802.1X using EAP authentication and (optionally) dynamically
-#	generated WEP keys
-# NONE = WPA is not used; plaintext or static WEP could be used
-# If not set, this defaults to: WPA-PSK WPA-EAP
-#
-# auth_alg: list of allowed IEEE 802.11 authentication algorithms
-# OPEN = Open System authentication (required for WPA/WPA2)
-# SHARED = Shared Key authentication (requires static WEP keys)
-# LEAP = LEAP/Network EAP (only used with LEAP)
-# If not set, automatic selection is used (Open System with LEAP enabled if
-# LEAP is allowed as one of the EAP methods).
-#
-# pairwise: list of accepted pairwise (unicast) ciphers for WPA
-# CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
-# TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
-# NONE = Use only Group Keys (deprecated, should not be included if APs support
-#	pairwise keys)
-# If not set, this defaults to: CCMP TKIP
-#
-# group: list of accepted group (broadcast/multicast) ciphers for WPA
-# CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
-# TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
-# WEP104 = WEP (Wired Equivalent Privacy) with 104-bit key
-# WEP40 = WEP (Wired Equivalent Privacy) with 40-bit key [IEEE 802.11]
-# If not set, this defaults to: CCMP TKIP WEP104 WEP40
-#
-# psk: WPA preshared key; 256-bit pre-shared key
-# The key used in WPA-PSK mode can be entered either as 64 hex-digits, i.e.,
-# 32 bytes or as an ASCII passphrase (in which case, the real PSK will be
-# generated using the passphrase and SSID). ASCII passphrase must be between
-# 8 and 63 characters (inclusive).
-# This field is not needed, if WPA-EAP is used.
-# Note: Separate tool, wpa_passphrase, can be used to generate 256-bit keys
-# from ASCII passphrase. This process uses lot of CPU and wpa_supplicant
-# startup and reconfiguration time can be optimized by generating the PSK only
-# only when the passphrase or SSID has actually changed.
-#
-# eapol_flags: IEEE 802.1X/EAPOL options (bit field)
-# Dynamic WEP key required for non-WPA mode
-# bit0 (1): require dynamically generated unicast WEP key
-# bit1 (2): require dynamically generated broadcast WEP key
-# 	(3 = require both keys; default)
-# Note: When using wired authentication, eapol_flags must be set to 0 for the
-# authentication to be completed successfully.
-#
-# mixed_cell: This option can be used to configure whether so called mixed
-# cells, i.e., networks that use both plaintext and encryption in the same
-# SSID, are allowed when selecting a BSS form scan results.
-# 0 = disabled (default)
-# 1 = enabled
-#
-# proactive_key_caching:
-# Enable/disable opportunistic PMKSA caching for WPA2.
-# 0 = disabled (default)
-# 1 = enabled
-#
-# wep_key0..3: Static WEP key (ASCII in double quotation, e.g. "abcde" or
-# hex without quotation, e.g., 0102030405)
-# wep_tx_keyidx: Default WEP key index (TX) (0..3)
-#
-# peerkey: Whether PeerKey negotiation for direct links (IEEE 802.11e DLS) is
-# allowed. This is only used with RSN/WPA2.
-# 0 = disabled (default)
-# 1 = enabled
-#peerkey=1
-#
-# Following fields are only used with internal EAP implementation.
-# eap: space-separated list of accepted EAP methods
-#	MD5 = EAP-MD5 (unsecure and does not generate keying material ->
-#			cannot be used with WPA; to be used as a Phase 2 method
-#			with EAP-PEAP or EAP-TTLS)
-#       MSCHAPV2 = EAP-MSCHAPv2 (cannot be used separately with WPA; to be used
-#		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
-#       OTP = EAP-OTP (cannot be used separately with WPA; to be used
-#		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
-#       GTC = EAP-GTC (cannot be used separately with WPA; to be used
-#		as a Phase 2 method with EAP-PEAP or EAP-TTLS)
-#	TLS = EAP-TLS (client and server certificate)
-#	PEAP = EAP-PEAP (with tunnelled EAP authentication)
-#	TTLS = EAP-TTLS (with tunnelled EAP or PAP/CHAP/MSCHAP/MSCHAPV2
-#			 authentication)
-#	If not set, all compiled in methods are allowed.
-#
-# identity: Identity string for EAP
-# anonymous_identity: Anonymous identity string for EAP (to be used as the
-#	unencrypted identity with EAP types that support different tunnelled
-#	identity, e.g., EAP-TTLS)
-# password: Password string for EAP
-# ca_cert: File path to CA certificate file (PEM/DER). This file can have one
-#	or more trusted CA certificates. If ca_cert and ca_path are not
-#	included, server certificate will not be verified. This is insecure and
-#	a trusted CA certificate should always be configured when using
-#	EAP-TLS/TTLS/PEAP. Full path should be used since working directory may
-#	change when wpa_supplicant is run in the background.
-#	On Windows, trusted CA certificates can be loaded from the system
-#	certificate store by setting this to cert_store://<name>, e.g.,
-#	ca_cert="cert_store://CA" or ca_cert="cert_store://ROOT".
-#	Note that when running wpa_supplicant as an application, the user
-#	certificate store (My user account) is used, whereas computer store
-#	(Computer account) is used when running wpasvc as a service.
-# ca_path: Directory path for CA certificate files (PEM). This path may
-#	contain multiple CA certificates in OpenSSL format. Common use for this
-#	is to point to system trusted CA list which is often installed into
-#	directory like /etc/ssl/certs. If configured, these certificates are
-#	added to the list of trusted CAs. ca_cert may also be included in that
-#	case, but it is not required.
-# client_cert: File path to client certificate file (PEM/DER)
-#	Full path should be used since working directory may change when
-#	wpa_supplicant is run in the background.
-#	Alternatively, a named configuration blob can be used by setting this
-#	to blob://<blob name>.
-# private_key: File path to client private key file (PEM/DER/PFX)
-#	When PKCS#12/PFX file (.p12/.pfx) is used, client_cert should be
-#	commented out. Both the private key and certificate will be read from
-#	the PKCS#12 file in this case. Full path should be used since working
-#	directory may change when wpa_supplicant is run in the background.
-#	Windows certificate store can be used by leaving client_cert out and
-#	configuring private_key in one of the following formats:
-#	cert://substring_to_match
-#	hash://certificate_thumbprint_in_hex
-#	for example: private_key="hash://63093aa9c47f56ae88334c7b65a4"
-#	Note that when running wpa_supplicant as an application, the user
-#	certificate store (My user account) is used, whereas computer store
-#	(Computer account) is used when running wpasvc as a service.
-#	Alternatively, a named configuration blob can be used by setting this
-#	to blob://<blob name>.
-# private_key_passwd: Password for private key file (if left out, this will be
-#	asked through control interface)
-# dh_file: File path to DH/DSA parameters file (in PEM format)
-#	This is an optional configuration file for setting parameters for an
-#	ephemeral DH key exchange. In most cases, the default RSA
-#	authentication does not use this configuration. However, it is possible
-#	setup RSA to use ephemeral DH key exchange. In addition, ciphers with
-#	DSA keys always use ephemeral DH keys. This can be used to achieve
-#	forward secrecy. If the file is in DSA parameters format, it will be
-#	automatically converted into DH params.
-# subject_match: Substring to be matched against the subject of the
-#	authentication server certificate. If this string is set, the server
-#	sertificate is only accepted if it contains this string in the subject.
-#	The subject string is in following format:
-#	/C=US/ST=CA/L=San Francisco/CN=Test AS/emailAddress=as@example.com
-# altsubject_match: Semicolon separated string of entries to be matched against
-#	the alternative subject name of the authentication server certificate.
-#	If this string is set, the server sertificate is only accepted if it
-#	contains one of the entries in an alternative subject name extension.
-#	altSubjectName string is in following format: TYPE:VALUE
-#	Example: EMAIL:server@example.com
-#	Example: DNS:server.example.com;DNS:server2.example.com
-#	Following types are supported: EMAIL, DNS, URI
-# phase1: Phase1 (outer authentication, i.e., TLS tunnel) parameters
-#	(string with field-value pairs, e.g., "peapver=0" or
-#	"peapver=1 peaplabel=1")
-#	'peapver' can be used to force which PEAP version (0 or 1) is used.
-#	'peaplabel=1' can be used to force new label, "client PEAP encryption",
-#	to be used during key derivation when PEAPv1 or newer. Most existing
-#	PEAPv1 implementation seem to be using the old label, "client EAP
-#	encryption", and wpa_supplicant is now using that as the default value.
-#	Some servers, e.g., Radiator, may require peaplabel=1 configuration to
-#	interoperate with PEAPv1; see eap_testing.txt for more details.
-#	'peap_outer_success=0' can be used to terminate PEAP authentication on
-#	tunneled EAP-Success. This is required with some RADIUS servers that
-#	implement draft-josefsson-pppext-eap-tls-eap-05.txt (e.g.,
-#	Lucent NavisRadius v4.4.0 with PEAP in "IETF Draft 5" mode)
-#	include_tls_length=1 can be used to force wpa_supplicant to include
-#	TLS Message Length field in all TLS messages even if they are not
-#	fragmented.
-#	sim_min_num_chal=3 can be used to configure EAP-SIM to require three
-#	challenges (by default, it accepts 2 or 3)
-# phase2: Phase2 (inner authentication with TLS tunnel) parameters
-#	(string with field-value pairs, e.g., "auth=MSCHAPV2" for EAP-PEAP or
-#	"autheap=MSCHAPV2 autheap=MD5" for EAP-TTLS)
-# Following certificate/private key fields are used in inner Phase2
-# authentication when using EAP-TTLS or EAP-PEAP.
-# ca_cert2: File path to CA certificate file. This file can have one or more
-#	trusted CA certificates. If ca_cert2 and ca_path2 are not included,
-#	server certificate will not be verified. This is insecure and a trusted
-#	CA certificate should always be configured.
-# ca_path2: Directory path for CA certificate files (PEM)
-# client_cert2: File path to client certificate file
-# private_key2: File path to client private key file
-# private_key2_passwd: Password for private key file
-# dh_file2: File path to DH/DSA parameters file (in PEM format)
-# subject_match2: Substring to be matched against the subject of the
-#	authentication server certificate.
-# altsubject_match2: Substring to be matched against the alternative subject
-#	name of the authentication server certificate.
-#
-# fragment_size: Maximum EAP fragment size in bytes (default 1398).
-#	This value limits the fragment size for EAP methods that support
-#	fragmentation (e.g., EAP-TLS and EAP-PEAP). This value should be set
-#	small enough to make the EAP messages fit in MTU of the network
-#	interface used for EAPOL. The default value is suitable for most
-#	cases.
-#
-# EAP-PSK variables:
-# eappsk: 16-byte (128-bit, 32 hex digits) pre-shared key in hex format
-# nai: user NAI
-#
-# EAP-PAX variables:
-# eappsk: 16-byte (128-bit, 32 hex digits) pre-shared key in hex format
-#
-# EAP-SAKE variables:
-# eappsk: 32-byte (256-bit, 64 hex digits) pre-shared key in hex format
-#	(this is concatenation of Root-Secret-A and Root-Secret-B)
-# nai: user NAI (PEERID)
-#
-# EAP-GPSK variables:
-# eappsk: Pre-shared key in hex format (at least 128 bits, i.e., 32 hex digits)
-# nai: user NAI (ID_Client)
-#
-# EAP-FAST variables:
-# pac_file: File path for the PAC entries. wpa_supplicant will need to be able
-#	to create this file and write updates to it when PAC is being
-#	provisioned or refreshed. Full path to the file should be used since
-#	working directory may change when wpa_supplicant is run in the
-#	background. Alternatively, a named configuration blob can be used by
-#	setting this to blob://<blob name>
-# phase1: fast_provisioning=1 option enables in-line provisioning of EAP-FAST
-#	credentials (PAC)
-#
-# wpa_supplicant supports number of "EAP workarounds" to work around
-# interoperability issues with incorrectly behaving authentication servers.
-# These are enabled by default because some of the issues are present in large
-# number of authentication servers. Strict EAP conformance mode can be
-# configured by disabling workarounds with eap_workaround=0.
-
-# Example blocks:
-
-# Simple case: WPA-PSK, PSK as an ASCII passphrase, allow all valid ciphers
-#network={
-#	ssid="simple"
-#	psk="very secret passphrase"
-#	priority=5
-#}
-
-# Same as previous, but request SSID-specific scanning (for APs that reject
-# broadcast SSID)
-#network={
-#	ssid="second ssid"
-#	scan_ssid=1
-#	psk="very secret passphrase"
-#	priority=2
-#}
-
-# Only WPA-PSK is used. Any valid cipher combination is accepted.
-#network={
-#	ssid="example"
-#	proto=WPA
-#	key_mgmt=WPA-PSK
-#	pairwise=CCMP TKIP
-#	group=CCMP TKIP WEP104 WEP40
-#	psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb
-#	priority=2
-#}
-
-# Only WPA-EAP is used. Both CCMP and TKIP is accepted. An AP that used WEP104
-# or WEP40 as the group cipher will not be accepted.
-#network={
-#	ssid="example"
-#	proto=RSN
-#	key_mgmt=WPA-EAP
-#	pairwise=CCMP TKIP
-#	group=CCMP TKIP
-#	eap=TLS
-#	identity="user@example.com"
-#	ca_cert="/etc/cert/ca.pem"
-#	client_cert="/etc/cert/user.pem"
-#	private_key="/etc/cert/user.prv"
-#	private_key_passwd="password"
-#	priority=1
-#}
-
-# EAP-PEAP/MSCHAPv2 configuration for RADIUS servers that use the new peaplabel
-# (e.g., Radiator)
-#network={
-#	ssid="example"
-#	key_mgmt=WPA-EAP
-#	eap=PEAP
-#	identity="user@example.com"
-#	password="foobar"
-#	ca_cert="/etc/cert/ca.pem"
-#	phase1="peaplabel=1"
-#	phase2="auth=MSCHAPV2"
-#	priority=10
-#}
-
-# EAP-TTLS/EAP-MD5-Challenge configuration with anonymous identity for the
-# unencrypted use. Real identity is sent only within an encrypted TLS tunnel.
-#network={
-#	ssid="example"
-#	key_mgmt=WPA-EAP
-#	eap=TTLS
-#	identity="user@example.com"
-#	anonymous_identity="anonymous@example.com"
-#	password="foobar"
-#	ca_cert="/etc/cert/ca.pem"
-#	priority=2
-#}
-
-# EAP-TTLS/MSCHAPv2 configuration with anonymous identity for the unencrypted
-# use. Real identity is sent only within an encrypted TLS tunnel.
-#network={
-#	ssid="example"
-#	key_mgmt=WPA-EAP
-#	eap=TTLS
-#	identity="user@example.com"
-#	anonymous_identity="anonymous@example.com"
-#	password="foobar"
-#	ca_cert="/etc/cert/ca.pem"
-#	phase2="auth=MSCHAPV2"
-#}
-
-# WPA-EAP, EAP-TTLS with different CA certificate used for outer and inner
-# authentication.
-#network={
-#	ssid="example"
-#	key_mgmt=WPA-EAP
-#	eap=TTLS
-#	# Phase1 / outer authentication
-#	anonymous_identity="anonymous@example.com"
-#	ca_cert="/etc/cert/ca.pem"
-#	# Phase 2 / inner authentication
-#	phase2="autheap=TLS"
-#	ca_cert2="/etc/cert/ca2.pem"
-#	client_cert2="/etc/cer/user.pem"
-#	private_key2="/etc/cer/user.prv"
-#	private_key2_passwd="password"
-#	priority=2
-#}
-
-# Both WPA-PSK and WPA-EAP is accepted. Only CCMP is accepted as pairwise and
-# group cipher.
-#network={
-#	ssid="example"
-#	bssid=00:11:22:33:44:55
-#	proto=WPA RSN
-#	key_mgmt=WPA-PSK WPA-EAP
-#	pairwise=CCMP
-#	group=CCMP
-#	psk=06b4be19da289f475aa46a33cb793029d4ab3db7a23ee92382eb0106c72ac7bb
-#}
-
-# Special characters in SSID, so use hex string. Default to WPA-PSK, WPA-EAP
-# and all valid ciphers.
-#network={
-#	ssid=00010203
-#	psk=000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
-#}
-
-
-# EAP-SIM with a GSM SIM or USIM
-#network={
-#	ssid="eap-sim-test"
-#	key_mgmt=WPA-EAP
-#	eap=SIM
-#	pin="1234"
-#	pcsc=""
-#}
-
-
-# EAP-PSK
-#network={
-#	ssid="eap-psk-test"
-#	key_mgmt=WPA-EAP
-#	eap=PSK
-#	identity="eap_psk_user"
-#	eappsk=06b4be19da289f475aa46a33cb793029
-#	nai="eap_psk_user@example.com"
-#}
-
-
-# IEEE 802.1X/EAPOL with dynamically generated WEP keys (i.e., no WPA) using
-# EAP-TLS for authentication and key generation; require both unicast and
-# broadcast WEP keys.
-#network={
-#	ssid="1x-test"
-#	key_mgmt=IEEE8021X
-#	eap=TLS
-#	identity="user@example.com"
-#	ca_cert="/etc/cert/ca.pem"
-#	client_cert="/etc/cert/user.pem"
-#	private_key="/etc/cert/user.prv"
-#	private_key_passwd="password"
-#	eapol_flags=3
-#}
-
-
-# LEAP with dynamic WEP keys
-#network={
-#	ssid="leap-example"
-#	key_mgmt=IEEE8021X
-#	eap=LEAP
-#	identity="user"
-#	password="foobar"
-#}
-
-# EAP-FAST with WPA (WPA or WPA2)
-#network={
-#	ssid="eap-fast-test"
-#	key_mgmt=WPA-EAP
-#	eap=FAST
-#	anonymous_identity="FAST-000102030405"
-#	identity="username"
-#	password="password"
-#	phase1="fast_provisioning=1"
-#	pac_file="/etc/wpa_supplicant.eap-fast-pac"
-#}
-
-#network={
-#	ssid="eap-fast-test"
-#	key_mgmt=WPA-EAP
-#	eap=FAST
-#	anonymous_identity="FAST-000102030405"
-#	identity="username"
-#	password="password"
-#	phase1="fast_provisioning=1"
-#	pac_file="blob://eap-fast-pac"
-#}
-
-# Plaintext connection (no WPA, no IEEE 802.1X)
-#network={
-#	ssid="plaintext-test"
-#	key_mgmt=NONE
-#}
-
-
-# Shared WEP key connection (no WPA, no IEEE 802.1X)
-#network={
-#	ssid="static-wep-test"
-#	key_mgmt=NONE
-#	wep_key0="abcde"
-#	wep_key1=0102030405
-#	wep_key2="1234567890123"
-#	wep_tx_keyidx=0
-#	priority=5
-#}
-
-
-# Shared WEP key connection (no WPA, no IEEE 802.1X) using Shared Key
-# IEEE 802.11 authentication
-#network={
-#	ssid="static-wep-test2"
-#	key_mgmt=NONE
-#	wep_key0="abcde"
-#	wep_key1=0102030405
-#	wep_key2="1234567890123"
-#	wep_tx_keyidx=0
-#	priority=5
-#	auth_alg=SHARED
-#}
-
-
-# IBSS/ad-hoc network with WPA-None/TKIP.
-#network={
-#	ssid="test adhoc"
-#	mode=1
-#	frequency=2412
-#	proto=WPA
-#	key_mgmt=WPA-NONE
-#	pairwise=NONE
-#	group=TKIP
-#	psk="secret passphrase"
-#}
-
-
-# Catch all example that allows more or less all configuration modes
-#network={
-#	ssid="example"
-#	scan_ssid=1
-#	key_mgmt=WPA-EAP WPA-PSK IEEE8021X NONE
-#	pairwise=CCMP TKIP
-#	group=CCMP TKIP WEP104 WEP40
-#	psk="very secret passphrase"
-#	eap=TTLS PEAP TLS
-#	identity="user@example.com"
-#	password="foobar"
-#	ca_cert="/etc/cert/ca.pem"
-#	client_cert="/etc/cert/user.pem"
-#	private_key="/etc/cert/user.prv"
-#	private_key_passwd="password"
-#	phase1="peaplabel=0"
-#}
-
-# Example of EAP-TLS with smartcard (openssl engine)
-#network={
-#	ssid="example"
-#	key_mgmt=WPA-EAP
-#	eap=TLS
-#	proto=RSN
-#	pairwise=CCMP TKIP
-#	group=CCMP TKIP
-#	identity="user@example.com"
-#	ca_cert="/etc/cert/ca.pem"
-#	client_cert="/etc/cert/user.pem"
-#
-#	engine=1
-#
-	# The engine configured here must be available. Look at
-	# OpenSSL engine support in the global section.
-	# The key available through the engine must be the private key
-	# matching the client certificate configured above.
-
-	# use the opensc engine
-	#engine_id="opensc"
-	#key_id="45"
-
-	# use the pkcs11 engine
-#	engine_id="pkcs11"
-#	key_id="id_45"
-
-	# Optional PIN configuration; this can be left out and PIN will be
-	# asked through the control interface
-#	pin="1234"
-#}
-
-# Example configuration showing how to use an inlined blob as a CA certificate
-# data instead of using external file
-#network={
-#	ssid="example"
-#	key_mgmt=WPA-EAP
-#	eap=TTLS
-#	identity="user@example.com"
-#	anonymous_identity="anonymous@example.com"
-#	password="foobar"
-#	ca_cert="blob://exampleblob"
-#	priority=20
-#}
-
-#blob-base64-exampleblob={
-#SGVsbG8gV29ybGQhCg==
-#}
-
-# Wildcard match for SSID (plaintext APs only). This example selects any
-# open AP regardless of its SSID.
-#network={
-#	key_mgmt=NONE
-#}
